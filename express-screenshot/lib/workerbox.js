// Generated by CoffeeScript 1.6.3
(function() {
  module.exports = (function() {
    var WorkerBox, config, configMod, jobPool, statistics;
    configMod = require('./config');
    jobPool = require('./jobPool');
    statistics = require('./statistics');
    statistics.expect(1000);
    config = configMod.get();
    return WorkerBox = (function() {
      function WorkerBox(conn, socket) {
        var _this = this;
        this.socket = socket;
        this.conn = conn;
        this.windowSize = config.workerConf.windowSize;
        this.boxDelivers = config.boxDelivers;
        this.boxblock = config.boxblock;
        this.expressbox = [];
        this.mailbox = [];
        this.tracebox = {};
        configMod.on('set', function(opts) {
          _this.boxDelivers = config.boxDelivers;
          if (opts.boxblock && opts.boxblock !== _this.boxblock) {
            clearInterval(_this._task);
            return _this.config();
          }
        });
        conn.addListener('message', function(msg) {
          return _this.receive(msg);
        });
        conn.addListener('close', function() {});
        this.config(config.workerConf);
      }

      WorkerBox.prototype.send = function(data) {
        var job, _i, _len;
        if (data.length) {
          this._send({
            method: 'POST',
            jobList: data
          });
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            job = data[_i];
            this.tracebox[job.id] = job;
          }
          console.log('has sent ' + data.length);
          return data.length = 0;
        }
      };

      WorkerBox.prototype.receive = function(msg) {
        msg = JSON.parse(msg);
        if (msg.method === "READY") {
          console.log('worker is ready ' + this.conn.id);
          return this._init();
        } else if (msg.method === "ADJUST") {
          statistics.statistics(msg.ackList.length);
          if (msg.ackList.length) {
            console.log('ack jobs ' + msg.ackList.length);
            this._ackJobs(msg.ackList);
          }
          return this.windowSize = msg.windowSize;
        } else if (msg.method === "LOG") {
          return console.log('conn.id:' + this.conn.id + '   ' + msg.msg);
        }
      };

      WorkerBox.prototype.add = function(job) {
        if (!job) {
          return;
        }
        if (this.windowSize <= 0) {
          console.log('----------cache job-------------');
          jobPool.push(job);
          return;
        }
        this.mailbox.push(job);
        if (this.mailbox.length > this.windowSize) {
          this.send(this.mailbox);
        }
      };

      WorkerBox.prototype._init = function() {
        var router,
          _this = this;
        this._task = setInterval((function() {
          if (_this.expressbox.length) {
            return _this.send(_this.expressbox);
          } else if (_this.mailbox.length) {
            return _this.send(_this.mailbox);
          }
        }), this.boxblock);
        router = require('./router');
        return router.addToBoxList(this);
      };

      WorkerBox.prototype.config = function(opts) {
        return this._send({
          method: 'CONFIG',
          opts: opts
        });
      };

      WorkerBox.prototype._send = function(data) {
        if (data) {
          return this.socket.send(this.conn.id, JSON.stringify(data));
        }
      };

      WorkerBox.prototype._ackJobs = function(ackList) {
        var job, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ackList.length; _i < _len; _i++) {
          job = ackList[_i];
          this.tracebox[job.jobId] = null;
          _results.push(delete this.tracebox[job.jobId]);
        }
        return _results;
      };

      WorkerBox.prototype.express = function(job) {
        if (!job) {

        }
      };

      WorkerBox.prototype.unBox = function() {
        var job, key, val, _i, _len, _ref, _ref1;
        console.log('unBoxing ... ' + this.conn.id);
        this.conn.removeAllListeners();
        clearInterval(this._task);
        _ref = this.mailbox;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          job = _ref[_i];
          jobPool.unshift(job);
        }
        _ref1 = this.tracebox;
        for (key in _ref1) {
          val = _ref1[key];
          jobPool.unshift(val);
        }
        return console.log('jobPool count:' + jobPool.count());
      };

      return WorkerBox;

    })();
  })();

}).call(this);
